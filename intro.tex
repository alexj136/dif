\section{Introduction}

\subsection{Implicit functions}
Modularity, a core concept in software engineering, is greatly aided by
parameterisation of programs. Parameterisation has dual facets: supplying and
consuming a parameter.  A key tension in large-scale software engineering is
between \emph{explicit} (e.g.~pure functional programming), and \emph{implicit}
parameterisation (e.g.~global state).  The former enables local reasoning but
can lead to repetitive supply of parameters.  Here is a simple example of the
problem:

\begin{minipage}{\linewidth}
\begin{lstlisting}[mathescape]
def compare(x: Int, y: Int)(comparator:
    Int => Int => Boolean): Boolean =
  comparator(x)(y)
...
compare(3, 4)(<=)
...
compare(17, 12)(<=)
...
\end{lstlisting}
\end{minipage}

Repeatedly passing functions like \texttt{<=} which are unlikely to change
frequently, is tedious, and impedes readability of large code bases. Default
parameters  are an early proposal for mediating this tension in a type-safe way.
The key idea is to annotate function arguments with their default value, to be
used whenever an invocation does not supply an argument:

\begin{minipage}{\linewidth}
\begin{lstlisting}[mathescape]
def compare(x: Int, y: Int)(comparator:
    Int => Int => Boolean = <=): Boolean =
  comparator(x)(y)
...
compare(3, 4)
...
compare(17, 12)
...
\end{lstlisting}
\end{minipage}

The compiler synthesises $\texttt{compare(3, 4)(<=)}$ from $\texttt{compare(3,
4)}$, and $\texttt{compare(17, 12)(<=)}$ from $\texttt{compare(17, 12)}$. The
missing argument indicates to the compiler that the default $\texttt{<=}$ should
be used. Default parameters have a key disadvantage: the default value is
hard-coded at the callee, and cannot be context dependent. Implicit arguments, a
strict generalisation of default parameters, were pioneered in Haskell
\cite{LLMS00}, and popularised as well as refined  in Scala \cite{OBLB18}: they
separate the \emph{callee's declaration} that an argument can be elided, from
the \emph{caller's choice} of elided values, allowing the latter to be context
dependent.

\begin{minipage}{\linewidth}
\begin{lstlisting}[mathescape]
def compare(x: Int, y: Int)(
    implicit comparator:
    Int => Int => Boolean): Boolean =
  comparator(x)(y)
...
implicit val cmp = <=
compare(3, 4)
...
implicit val cmp = >
compare(17, 12)
...
\end{lstlisting}
\end{minipage}

In this example $\texttt{compare(3, 4)}$ is rewritten as above, but
$\texttt{compare(17, 12)}$ becomes $\texttt{compare(17, 12)(>)}$, i.e.~a
different implicit argument is synthesised. The disambiguation between several
providers of implicit arguments happens at compile-time using type and scope
information. Programs where elided arguments cannot be disambiguated at
compile-time are rejected as ill-formed. Hence type-safety is not compromised.

\subsection{Dependent Object Types (DOT)}

DOT is a calculus intended as a step towards a theoretical foundation for the
programming language Scala and its type system \cite{AMO12}. DOT models a
restricted subset of Scala -- the base-calculus includes Scala's key features
from a type theory perspective, such as path-dependency, abstract type members
and a subtyping hierarchy with maximal type $\top$ and minimal type $\bot$.
Omitted are features of Scala that are less important from this perspective,
such as traits, classes and inheritance. We now look briefly at two important
features of DOT.

\paragraph{Abstract Type Members}

Abstract type members are a feature of Scala that allow for generic programming.
In Scala, a trait, class or object may declare an abstract type member. The
trait, class or object may then declare or define methods over that type. Below
is a trait \texttt{A} with an abstract type member \texttt{B}. The trait also
contains a method member \texttt{consumeB} that consumes a value of type
\texttt{B}.

\begin{minipage}{\linewidth}
\begin{lstlisting}[mathescape]
trait A {
    type B
    def consumeB(b: B): String
}
\end{lstlisting}
\end{minipage}

\noindent Any object may then declare itself a subtype of \texttt{A}, and
provide a concrete type in place of the abstract type member. Such an object may
implement method members over that type:

\begin{minipage}{\linewidth}
\begin{lstlisting}[mathescape]
object C extends A {
    type B = Int
    def consumeB(b: Int): String =
      b.toString
}
\end{lstlisting}
\end{minipage}

\noindent Like Scala, DOT also includes abstract type members, and thus the
above pattern is possible. We write $\TDEC{A}{S}{S'}$ to denote an object with a
type member $A$, whose lower bound is $S$ and upper bound is $S'$. Scala's
syntax \texttt{type T = U} is then equivalent to DOT's $\TDEC{T}{U}{U}$ - we let
\texttt{U} be the upper and lower bound. In DOT we can define a completely
abstract type member (equivalent to just \texttt{type T} in Scala) by using
$\bot$ and $\top$ as lower and upper bounds respectively. Conversely we can
define a fully specified type member by using a single specified type as both
the lower and upper bound.

\paragraph{Path-dependent Types}
Path-dependent types are a restricted form of dependent types \cite{AGORS16}.
Instead of allowing arbitrary computations over values in types, objects with
type members are the only values allowed, and selection of type members is the
only permitted operation on those objects.

Path-dependent types with function arrows can be used to recover
Hindley-Damas-Milner style polymorphism despite the absence of type variables,
via the passing of an object with a type member \cite{AGORS16}. Consider the
function \texttt{id} in an ML-like language with Hindley-Damas-Milner
polymorphism as below:

\begin{minipage}{\linewidth}
\begin{lstlisting}[mathescape]
    id : $\forall$a. a $\rightarrow$ a
    id x = x
\end{lstlisting}
\end{minipage}

We can rewrite this in DOT as below, with an additional parameter used to pass the type of the parameter x:

\begin{minipage}{\linewidth}
\begin{lstlisting}[mathescape]
    id : $\forall$(u: {A: S}) $\forall$(v: u.A) u.A
    id = $\lambda$(u: {A: S}) $\lambda$(x: u.A) x
\end{lstlisting}
\end{minipage}

\subsection{Dependent object types with Implicit Functions (DIF)}

The type safety of implicit functions in Scala and its compiler known as
\emph{Dotty}, has been evidenced by the type-safe integration of implicit
functions into lambda calculus \cite{OBLB18}. This evidence could be further
strengthened by their type-safe integration into DOT, the calculus on which the
Dotty compiler is based. In the remainder of this paper, we present DIF, a
type-safe integration of implicit functions into DOT. We demonstrate that the
type class pattern, a typical use case of implicit functions in Scala, which
also leverages abstract type members and path-dependent types, can be translated
typably into DIF. DIF is shown to be type-safe by translation into the DOT
calculus presented in \cite{AGORS16}. Combined with Hindley-Damas-Milner style
parametric polymorphism recovered in DOT via path-dependent types, implicit
functions can be used to recover ad-hoc polymorphism in DOT via the type class
pattern.

Implicits are widely used in Scala... \TODO{Talk about why this is important to
the Scala community, use in Akka etc}

\paragraph{Type classes} Type classes \cite{K88, WB89} are a mechanism to allow
ad-hoc polymorphism in languages with parametric polymorphism. Parametrically
polymorphic type variables may be \emph{constrained}, such that they can only be
instantiated by types over which a user-defined set of functions exist. Further
functions can then be defined over all types for which the set of functions are
defined. A typical example of a type class is \texttt{Show}. Note that for this
example we use Haskell-style listings, as Haskell is the most well-known
language with type classes. In a single program, we might want to use a
function \texttt{print} to print values over many different types, for example
we might want to write \texttt{print 1}, \texttt{print True} and \texttt{print
[1, 2]} in the same program. To acheive this with type classes, we give
\texttt{print} the following signature:

\begin{lstlisting}[mathescape]
    print :: Show a => a -> IO ()
\end{lstlisting}

\noindent This signature tells us that where \texttt{a} is a type in the
\texttt{Show} type class, \texttt{print} takes an \texttt{a} and returns
\texttt{IO ()} (in Haskell, \texttt{()} is the unit type and the type
constructor \texttt{IO} represents a type obtained as a result of performing
IO).

\TODO{More on Type classes}

\paragraph{Example} The type class pattern \cite{OBLB18} can be implemented in
DIF, and maps more closely to the type class pattern as is used in Scala. The
example leverages DOT's path-dependency, which exhibits parametric polymorphism
by passing objects with type members. The \emph{dictionary passing} of languages
with type classes can then be implemented with implicit functions. Example 1
shows the type class pattern in Scala, and example 2 shows the type class
pattern adapted for DIF.

\begin{figure*}[h]
\begin{lstlisting}[mathescape]
    trait Ord[T] {
        def compare(x: A, y: A): Boolean
    }

    def comp[T](x: A, y: A)(implicit ev: Ord[T]): Boolean = ev.compare(x, y)

    implicit def intOrd: Ord[Int] = new Ord[Int] {
        def compare(x: Int, y: Int): Boolean = a < b
    }
    ...
    comp(1, 2)
    ...
\end{lstlisting}
\caption*{\textbf{Example 1.} The type class pattern in Scala}
\end{figure*}

\begin{figure*}[h]
\begin{lstlisting}[mathescape]
    let ord_package = $\nu$(ord_p) {
        Ord = $\mu$(self: {
            A: $\bot$..$\top$
            compare: $\forall$(x: self.A, y: self.A)Boolean
        })
        comp: $\forall$(t: {A: $\bot$..$\top$})$\forall$(x: t.A, y: t.A)$\forall$$\IMP$(ev: ord_p.Ord$\wedge${A: $\bot$..$\top$})Boolean =
            $\lambda$(t: {A: $\bot$..$\top$})$\lambda$(x: t.A, y: t.A)$\IMP$.compare(x, y)
    } in
    let $\IMP$: ord_package.Ord$\wedge${A: Int..Int} = $\nu$(self: {
            A = Int
            compare: $\forall$(x: self.A, y: self.A)Boolean =
                $\lambda$(x: self.A, y: self.A) x < y
        })
    in
    ...
    ord_package.comp(1, 2)
    ...
\end{lstlisting}
\caption*{\textbf{Example 2.} The type class pattern in DIF}
\end{figure*}
