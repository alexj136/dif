\section{Introduction}

Here we extend the DOT calculus \cite{AGORS16} with implicit functions as in
\cite{OBLB18}. We term the resulting calculus DIF (DOT with Implicit Functions).

\subsection{Related work}

Other papers on DOT are \cite{ARO14, AR17, AR16, AMO12}

\subsection{Examples}

\subsubsection{The Type Class Pattern}

The type class pattern \cite{OBLB18} can be implemented in DIF, and maps more
closely to the type class pattern as is used in Scala. The example leverages
DOT's path-dependency, which exhibits parametric polymorphism by passing
objects with type members. The \emph{dictionary passing} \cite{K88, WB89} of
languages with type classes can then be implemented with implicit functions.

\begin{lstlisting}[mathescape]
trait Ord[T] {
    def compare(x: A, y: A): Boolean
}

def comp[T](x: A, y: A)(implicit ev: Ord[T]): Boolean = ev.compare(x, y)

implicit def intOrd: Ord[Int] = new Ord[Int] {
    def compare(x: Int, y: Int): Boolean = a < b
}

comp(1, 2)
\end{lstlisting}

\hrule

\begin{lstlisting}[mathescape]
let ord_package = $\nu$(ord_p) {
    Ord = $\mu$(self: {
        A: $\bot$..$\top$
        compare: $\forall$(x: self.A, y: self.A)Boolean
    })
    comp: $\forall$(t: {A: $\bot$..$\top$})$\forall$(x: t.A, y: t.A)$\forall$$\IMP$(ev: ord_p.Ord$\wedge${A: $\bot$..$\top$})Boolean =
        $\lambda$(t: {A: $\bot$..$\top$})$\lambda$(x: t.A, y: t.A)$\IMP$.compare(x, y)
} in
let $\IMP$: ord_package.Ord$\wedge${A: Int..Int} = $\nu$(self: {
        A = Int
        compare: $\forall$(x: self.A, y: self.A)Boolean =
            $\lambda$(x: self.A, y: self.A) x < y
    })
in
...
ord_package.comp(1, 2)
...
\end{lstlisting}
