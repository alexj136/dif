\section{Introduction}

\subsection{Implicit functions}
Modularity, a core concept in software engineering, is greatly aided by
parameterisation of programs. Parameterisation has dual facets: supplying and
consuming a parameter.  A key tension in large-scale software engineering is
between \emph{explicit} (e.g.~pure functional programming), and \emph{implicit}
parameterisation (e.g.~global state).  The former enables local reasoning but
can lead to repetitive supply of parameters.  Here is a simple example of the
problem:

\begin{minipage}{\linewidth}
\begin{lstlisting}[mathescape]
    def compare(x: Int, y: Int,
            comparator: Int => Int => Boolean): Boolean =
        comparator(x)(y)
    ...
    compare(3, 4, <=)
    ...
    compare(17, 12, <=)
    ...
\end{lstlisting}
\end{minipage}

Repeatedly passing functions like \texttt{<=} which are unlikely to change
frequently, is tedious, and impedes readability of large code bases. Default
parameters  are an early proposal for mediating this tension in a type-safe way.
The key idea is to annotate function arguments with their default value, to be
used whenever an invocation does not supply an argument:

\begin{minipage}{\linewidth}
\begin{lstlisting}[mathescape]
    def compare(x: Int, y: Int,
            comparator: Int => Int => Boolean = <=): Boolean =
        comparator(x)(y)
    ...
    compare(3, 4)
    ...
    compare(17, 12)
    ...
\end{lstlisting}
\end{minipage}

The compiler synthesises $\texttt{compare(3, 4, <=)}$ from $\texttt{compare(3,
4)}$, and $\texttt{compare(17, 12, <=)}$ from $\texttt{compare(17, 12)}$.
Default parameters have a key disadvantage: the default value is hard-coded at
the callee, and cannot be context dependent. Implicit arguments, a strict
generalisation of default parameters, were pioneered in Haskell \cite{LLMS00},
and popularised as well as refined  in Scala \cite{OBLB18}: they separate the
\emph{callee's declaration} that an argument can be elided, from the
\emph{caller's choice} of elided values, allowing the latter to be context
dependent.

\begin{minipage}{\linewidth}
\begin{lstlisting}[mathescape]
    def compare(x: Int, y: Int,
            implicit comparator: Int => Int => Boolean): Boolean =
        comparator(x)(y)
    ...
    implicit val cmp = <=
    compare(3, 4)
    ...
    implicit val cmp = >
    compare(17, 12)
    ...
\end{lstlisting}
\end{minipage}

In this example $\texttt{compare(3, 4)}$ is rewritten as above, but
$\texttt{compare(17, 12)}$ becomes $\texttt{compare(17, 12, >)}$, i.e.~a
different implicit argument is synthesised. The disambiguation between several
providers of implicit arguments happens at compile-time using type and scope
information. Programs where elided arguments cannot be disambiguated at
compile-time are rejected as ill-formed. Hence type-safety is not compromised.

\subsection{Dependent Object Types (DOT)}

DOT is a calculus intended as a step towards a theoretical foundation for the
programming language Scala and its type system \cite{AMO12}. DOT models a
restricted subset of Scala -- the base-calculus includes Scala's key features
from a type theory perspective, such as path-dependency and abstract type
members. Omitted are features of Scala that are less important from this
perspective, such as traits, classes and inheritance.

Other papers on DOT are \cite{ARO14, AR17, AR16}

\subsection{Abstract Type Members}

Abstract type members are a feature of DOT dependent on DOT's object-based
nature. Abstract type members allow types to be members of objects (and their
types), named with labels. The labels can correspond to more or less specific
types via upper and lower bound syntax. We write $\TDEC{A}{S}{S'}$ to denote an
object with a type member $A$, whose lower bound is $S$ and upper bound is
$S'$. We can define a completely abstract type member by using $\bot$ and
$\top$ as lower and upper bounds respectively. Conversely we can define a fully
specified type member by using a single specified type as both the lower and
upper bound.

\subsection{Path-dependent Types}
Path-dependent types are a restricted form of dependent types that retain decidability \TODO{citation}. Instead of allowing arbitrary computations over values in types, objects with type members are the only values allowed, and  selection of type members is the only permitted operation on those objects. This
selection is decidable \TODO{citation}. Path-dependent types with function arrows can be used to recover Hindley-Damas-Milner style polymorphism despite the absence of type variables, via the passing of an object with a type member. Consider the function \texttt{id} in an ML-like language with Hindley-Damas-Milner polymorphism as below:

\begin{minipage}{\linewidth}
\begin{lstlisting}[mathescape]
    id : $\forall$a. a $\rightarrow$ a
    id x = x
\end{lstlisting}
\end{minipage}

We can rewrite this in DOT as below, with an additional parameter used to pass the type of the parameter x:

\begin{minipage}{\linewidth}
\begin{lstlisting}[mathescape]
    id : $\forall$(u: {A: S}) $\forall$(v: u.A) u.A
    id = $\lambda$(u: {A: S}) $\lambda$(x: u.A) x
\end{lstlisting}
\end{minipage}

\subsection{Dependent object types with Implicit Functions (DIF)}

The type safety of implicit functions in Scala has been evidenced by the
type-safe integration of implicit functions into lambda calculus \cite{OBLB18},
but this evidence could be further strengthened by their type-safe integration
into DOT, a calculus much more closely related to Scala. In the remainder of
this paper, we do exactly this -- we present DIF, a type-safe integration of
implicit functions into DOT. We demonstrate that the type class patter, a
typical use case of implicit functions in Scala, can be translated typably into
DIF. DIF is shown to be type-safe by translation into the DOT calculus of
\cite{AGORS16}. Combined with Hindley-Damas-Milner style parametric polymorphism recovered in DOT via path-dependent types, implicit functions can be used to recover ad-hoc polymorphism in DOT via the type class pattern.

\subsection{Examples}

\subsubsection{The Type Class Pattern}

The type class pattern \cite{OBLB18} can be implemented in DIF, and maps more
closely to the type class pattern as is used in Scala. The example leverages
DOT's path-dependency, which exhibits parametric polymorphism by passing
objects with type members. The \emph{dictionary passing} \cite{K88, WB89} of
languages with type classes can then be implemented with implicit functions.

\begin{minipage}{\textwidth}
\begin{lstlisting}[mathescape]
trait Ord[T] {
    def compare(x: A, y: A): Boolean
}

def comp[T](x: A, y: A)(implicit ev: Ord[T]): Boolean = ev.compare(x, y)

implicit def intOrd: Ord[Int] = new Ord[Int] {
    def compare(x: Int, y: Int): Boolean = a < b
}

comp(1, 2)
\end{lstlisting}
\center{Example: the type class pattern in Scala}
\end{minipage}

\vspace{2mm}
\hrule

\begin{minipage}{\textwidth}
\begin{lstlisting}[mathescape]
let ord_package = $\nu$(ord_p) {
    Ord = $\mu$(self: {
        A: $\bot$..$\top$
        compare: $\forall$(x: self.A, y: self.A)Boolean
    })
    comp: $\forall$(t: {A: $\bot$..$\top$})$\forall$(x: t.A, y: t.A)$\forall$$\IMP$(ev: ord_p.Ord$\wedge${A: $\bot$..$\top$})Boolean =
        $\lambda$(t: {A: $\bot$..$\top$})$\lambda$(x: t.A, y: t.A)$\IMP$.compare(x, y)
} in
let $\IMP$: ord_package.Ord$\wedge${A: Int..Int} = $\nu$(self: {
        A = Int
        compare: $\forall$(x: self.A, y: self.A)Boolean =
            $\lambda$(x: self.A, y: self.A) x < y
    })
in
...
ord_package.comp(1, 2)
...
\end{lstlisting}
\center{Example: the type class pattern in DIF}
\end{minipage}
