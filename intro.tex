\section{Introduction}

Here we extend the DOT calculus \cite{AGORS16} with implicit functions as in
\cite{OBLB18}. We term the resulting calculus DIF (DOT with Implicit Functions).

\subsection{Related work}

Other papers on DOT are \cite{ARO14, AR17, AR16, AMO12}

\subsection{Examples}

\subsubsection{The Type Class Pattern}

\begin{lstlisting}[mathescape]
trait Ord[T] {
    def compare(x: A, y: A): Boolean
}

def comp[T](x: A, y: A)(implicit ev: Ord[T]): Boolean = ev.compare(x, y)

implicit def intOrd: Ord[Int] = new Ord[Int] {
    def compare(x: Int, y: Int): Boolean = a < b
}

comp(1, 2)
\end{lstlisting}

\begin{lstlisting}[mathescape]
let ord_package = $\nu$(ord_p) {
    Ord = $\mu$(self: {
        A: $\bot$..$\top$
        compare: $\forall$(x: self.A, y: self.A)Boolean
    })
    comp: $\forall$(t: {A: $\bot$..$\top$})$\forall$(x: t.A, y: t.A)$\forall$$\IMP$(ev: ord_p.Ord$\wedge${A: $\bot$..$\top$})Boolean =
        $\lambda$(t: {A: $\bot$..$\top$})$\lambda$(x: t.A, y: t.A)$\IMP$.compare(x, y)
in
let $\IMP$: ord_p.Ord$\wedge${A: $\bot$..Int} = $\mu$(self: {
        A: $\bot$..Int
        compare: $\forall$(x: self.A, y: self.A)Boolean =
            $\lambda$(x: self.A, y: self.A) x < y
    })
in
...
ord_package.comp(1, 2)
...
\end{lstlisting}
